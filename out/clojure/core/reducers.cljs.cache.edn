;; Analyzed by ClojureScript 0.0-3308
{:use-macros nil, :excludes #{reduce take map mapcat cat take-while remove drop flatten filter}, :name clojure.core.reducers, :imports nil, :requires {core cljs.core, cljs.core cljs.core}, :uses nil, :defs {t358 {:num-fields 4, :protocols #{clojure.core.reducers/CollFold cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :name clojure.core.reducers/t358, :file "out/clojure/core/reducers.cljs", :type true, :anonymous true, :column 6, :line 85, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}}, t355 {:num-fields 4, :protocols #{clojure.core.reducers/CollFold cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :name clojure.core.reducers/t355, :file "out/clojure/core/reducers.cljs", :type true, :anonymous true, :column 6, :line 85, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}}, reduce {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 33, :column 7, :end-line 33, :end-column 13, :arglists (quote ([f coll] [f init coll])), :doc "Like core/reduce except:\n     When init is not provided, (f) is used.\n     Maps are reduced with reduce-kv", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f init coll]), :arglists ([f coll] [f init coll]), :arglists-meta (nil nil)}}, :name clojure.core.reducers/reduce, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f init coll]), :arglists ([f coll] [f init coll]), :arglists-meta (nil nil)}, :method-params ([f coll] [f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 33, :end-line 33, :max-fixed-arity 3, :fn-var true, :arglists ([f coll] [f init coll]), :doc "Like core/reduce except:\n     When init is not provided, (f) is used.\n     Maps are reduced with reduce-kv"}, ->t355 {:protocol-inline nil, :meta {:anonymous true, :protocols #{clojure.core.reducers/CollFold cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([folder coll xf meta356])), :file nil}, :protocols #{clojure.core.reducers/CollFold cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :name clojure.core.reducers/->t355, :variadic false, :file "out/clojure/core/reducers.cljs", :method-params ([folder coll xf meta356]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 6, :factory :positional, :line 85, :max-fixed-arity 4, :fn-var true, :arglists (quote ([folder coll xf meta356])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}}, take {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 164, :column 13, :end-line 164, :end-column 17, :arglists (quote ([n] [n coll])), :doc "Ends the reduction of coll after consuming n values.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}}, :name clojure.core.reducers/take, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 164, :end-line 164, :max-fixed-arity 2, :fn-var true, :arglists ([n] [n coll]), :doc "Ends the reduction of coll after consuming n values."}, map {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 96, :column 13, :end-line 96, :end-column 16, :arglists (quote ([f] [f coll])), :doc "Applies f to every value in the reduction of coll. Foldable.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name clojure.core.reducers/map, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 96, :end-line 96, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Applies f to every value in the reduction of coll. Foldable."}, foldcat {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 237, :column 7, :end-line 237, :end-column 14, :arglists (quote ([coll])), :doc "Equivalent to (fold cat append! coll)"}, :name clojure.core.reducers/foldcat, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 237, :end-line 237, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Equivalent to (fold cat append! coll)"}, reducer {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 66, :column 7, :end-line 66, :end-column 14, :arglists (quote ([coll xf])), :doc "Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn."}, :name clojure.core.reducers/reducer, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 14, :method-params ([coll xf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 66, :end-line 66, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll xf])), :doc "Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn."}, mapcat {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 106, :column 13, :end-line 106, :end-column 19, :arglists (quote ([f] [f coll])), :doc "Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name clojure.core.reducers/mapcat, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 106, :end-line 106, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable."}, ->t349 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([reducer coll xf meta350])), :file nil}, :protocols #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :name clojure.core.reducers/->t349, :variadic false, :file "out/clojure/core/reducers.cljs", :method-params ([reducer coll xf meta350]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 6, :factory :positional, :line 72, :max-fixed-arity 4, :fn-var true, :arglists (quote ([reducer coll xf meta350])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}}, cat {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 213, :column 7, :end-line 213, :end-column 10, :arglists (quote ([] [ctor] [left right])), :doc "A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([] [ctor] [left right]), :arglists ([] [ctor] [left right]), :arglists-meta (nil nil nil)}}, :name clojure.core.reducers/cat, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 10, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([] [ctor] [left right]), :arglists ([] [ctor] [left right]), :arglists-meta (nil nil nil)}, :method-params ([] [ctor] [left right]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 213, :end-line 213, :max-fixed-arity 2, :fn-var true, :arglists ([] [ctor] [left right]), :doc "A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat."}, take-while {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 152, :column 13, :end-line 152, :end-column 23, :arglists (quote ([pred] [pred coll])), :doc "Ends the reduction of coll when (pred val) returns logical false.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name clojure.core.reducers/take-while, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 23, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 152, :end-line 152, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Ends the reduction of coll when (pred val) returns logical false."}, remove {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 145, :column 13, :end-line 145, :end-column 19, :arglists (quote ([pred] [pred coll])), :doc "Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name clojure.core.reducers/remove, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 145, :end-line 145, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."}, fjjoin {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 29, :column 8, :end-line 29, :end-column 14, :private true, :arglists (quote ([task]))}, :private true, :name clojure.core.reducers/fjjoin, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 14, :method-params ([task]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 29, :end-line 29, :max-fixed-arity 1, :fn-var true, :arglists (quote ([task]))}, fjinvoke {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 23, :column 8, :end-line 23, :end-column 16, :private true, :arglists (quote ([f]))}, :private true, :name clojure.core.reducers/fjinvoke, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 16, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 23, :end-line 23, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f]))}, ->t352 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([reducer coll xf meta353])), :file nil}, :protocols #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :name clojure.core.reducers/->t352, :variadic false, :file "out/clojure/core/reducers.cljs", :method-params ([reducer coll xf meta353]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 6, :factory :positional, :line 72, :max-fixed-arity 4, :fn-var true, :arglists (quote ([reducer coll xf meta353])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}}, CollFold {:meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 46, :column 14, :end-line 46, :end-column 22, :doc nil, :protocol-symbol true, :protocol-info {:methods {coll-fold [[coll n combinef reducef]]}}}, :protocol-symbol true, :name clojure.core.reducers/CollFold, :file "out/clojure/core/reducers.cljs", :end-column 22, :column 1, :line 46, :protocol-info {:methods {coll-fold [[coll n combinef reducef]]}}, :info nil, :end-line 46, :impls #{nil object cljs.core/PersistentVector clojure.core.reducers/t355 clojure.core.reducers/Cat clojure.core.reducers/t358}, :doc nil}, t352 {:num-fields 4, :protocols #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :name clojure.core.reducers/t352, :file "out/clojure/core/reducers.cljs", :type true, :anonymous true, :column 6, :line 72, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}}, folder {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 79, :column 7, :end-line 79, :end-column 13, :arglists (quote ([coll xf])), :doc "Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn."}, :name clojure.core.reducers/folder, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 13, :method-params ([coll xf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 79, :end-line 79, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll xf])), :doc "Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn."}, append! {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 232, :column 7, :end-line 232, :end-column 14, :arglists (quote ([acc x])), :doc ".adds x to acc and returns acc"}, :name clojure.core.reducers/append!, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 14, :method-params ([acc x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 232, :end-line 232, :max-fixed-arity 2, :fn-var true, :arglists (quote ([acc x])), :doc ".adds x to acc and returns acc"}, ->Cat {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 193, :column 10, :end-line 193, :end-column 13, :protocols #{clojure.core.reducers/CollFold cljs.core/ICounted cljs.core/ISeqable cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/ICounted cljs.core/ISeqable cljs.core/IReduce}, :factory :positional, :arglists (quote ([cnt left right]))}, :protocols #{clojure.core.reducers/CollFold cljs.core/ICounted cljs.core/ISeqable cljs.core/IReduce}, :name clojure.core.reducers/->Cat, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 13, :method-params ([cnt left right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 193, :end-line 193, :max-fixed-arity 3, :fn-var true, :arglists (quote ([cnt left right])), :skip-protocol-flag #{cljs.core/ICounted cljs.core/ISeqable cljs.core/IReduce}}, drop {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 178, :column 13, :end-line 178, :end-column 17, :arglists (quote ([n] [n coll])), :doc "Elides the first n values from the reduction of coll.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}}, :name clojure.core.reducers/drop, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 178, :end-line 178, :max-fixed-arity 2, :fn-var true, :arglists ([n] [n coll]), :doc "Elides the first n values from the reduction of coll."}, fold {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 49, :column 7, :end-line 49, :end-column 11, :arglists (quote ([reducef coll] [combinef reducef coll] [n combinef reducef coll])), :doc "Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef). combinef must be associative, and, when called with no\n  arguments, (combinef) must produce its identity element. These\n  operations may be performed in parallel, but the results will\n  preserve order.\n\n  Note: Performing operations in parallel is currently not implemented.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([reducef coll] [combinef reducef coll] [n combinef reducef coll]), :arglists ([reducef coll] [combinef reducef coll] [n combinef reducef coll]), :arglists-meta (nil nil nil)}}, :name clojure.core.reducers/fold, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([reducef coll] [combinef reducef coll] [n combinef reducef coll]), :arglists ([reducef coll] [combinef reducef coll] [n combinef reducef coll]), :arglists-meta (nil nil nil)}, :method-params ([reducef coll] [combinef reducef coll] [n combinef reducef coll]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 49, :end-line 49, :max-fixed-arity 4, :fn-var true, :arglists ([reducef coll] [combinef reducef coll] [n combinef reducef coll]), :doc "Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef). combinef must be associative, and, when called with no\n  arguments, (combinef) must produce its identity element. These\n  operations may be performed in parallel, but the results will\n  preserve order.\n\n  Note: Performing operations in parallel is currently not implemented."}, Cat {:num-fields 3, :protocols #{clojure.core.reducers/CollFold cljs.core/ICounted cljs.core/ISeqable cljs.core/IReduce}, :name clojure.core.reducers/Cat, :file "out/clojure/core/reducers.cljs", :end-column 13, :type true, :column 10, :line 193, :record false, :end-line 193, :skip-protocol-flag #{cljs.core/ICounted cljs.core/ISeqable cljs.core/IReduce}}, flatten {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 130, :column 13, :end-line 130, :end-column 20, :arglists (quote ([] [coll])), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection.", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}}, :name clojure.core.reducers/flatten, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}, :method-params ([] [coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 130, :end-line 130, :max-fixed-arity 1, :fn-var true, :arglists ([] [coll]), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection."}, filter {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 117, :column 13, :end-line 117, :end-column 19, :arglists (quote ([pred] [pred coll])), :doc "Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name clojure.core.reducers/filter, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 117, :end-line 117, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."}, ->t358 {:protocol-inline nil, :meta {:anonymous true, :protocols #{clojure.core.reducers/CollFold cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([folder coll xf meta359])), :file nil}, :protocols #{clojure.core.reducers/CollFold cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :name clojure.core.reducers/->t358, :variadic false, :file "out/clojure/core/reducers.cljs", :method-params ([folder coll xf meta359]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 6, :factory :positional, :line 85, :max-fixed-arity 4, :fn-var true, :arglists (quote ([folder coll xf meta359])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}}, fjtask {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 20, :column 8, :end-line 20, :end-column 14, :private true, :arglists (quote ([f]))}, :private true, :name clojure.core.reducers/fjtask, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 14, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 20, :end-line 20, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f]))}, monoid {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 242, :column 7, :end-line 242, :end-column 13, :arglists (quote ([op ctor])), :doc "Builds a combining fn out of the supplied operator and identity\n  constructor. op must be associative and ctor called with no args\n  must return an identity value for it."}, :name clojure.core.reducers/monoid, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 13, :method-params ([op ctor]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 242, :end-line 242, :max-fixed-arity 2, :fn-var true, :arglists (quote ([op ctor])), :doc "Builds a combining fn out of the supplied operator and identity\n  constructor. op must be associative and ctor called with no args\n  must return an identity value for it."}, coll-fold {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 47, :column 4, :end-line 47, :end-column 13, :protocol clojure.core.reducers/CollFold, :doc nil, :arglists (quote ([coll n combinef reducef]))}, :protocol clojure.core.reducers/CollFold, :name clojure.core.reducers/coll-fold, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 13, :method-params ([coll n combinef reducef]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 46, :end-line 47, :max-fixed-arity 4, :fn-var true, :arglists (quote ([coll n combinef reducef])), :doc nil}, t349 {:num-fields 4, :protocols #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :name clojure.core.reducers/t349, :file "out/clojure/core/reducers.cljs", :type true, :anonymous true, :column 6, :line 72, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}}, foldvec {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 273, :column 8, :end-line 273, :end-column 15, :private true, :arglists (quote ([v n combinef reducef]))}, :private true, :name clojure.core.reducers/foldvec, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 15, :method-params ([v n combinef reducef]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 273, :end-line 273, :max-fixed-arity 4, :fn-var true, :arglists (quote ([v n combinef reducef]))}, fjfork {:protocol-inline nil, :meta {:file "/Users/pietromenna/git/specter/out/clojure/core/reducers.cljs", :line 26, :column 8, :end-line 26, :end-column 14, :private true, :arglists (quote ([task]))}, :private true, :name clojure.core.reducers/fjfork, :variadic false, :file "out/clojure/core/reducers.cljs", :end-column 14, :method-params ([task]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 26, :end-line 26, :max-fixed-arity 1, :fn-var true, :arglists (quote ([task]))}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:else}, :order [:else]}, :doc "A library for reduction and parallel folding. Alpha and subject\n      to change.  Note that fold and its derivatives require\n      jsr166y.jar for fork/join support. See Clojure's pom.xml for the\n      dependency info."}